# Slither Insight 102

————当我们在讨论重入时，我们在讨论什么

写于2024年6月22日22:44
---

写这篇文章的时候，收到了之前那篇[SAST文章](https://2024.esec-fse.org/details/fse-2024-research-papers/16/Static-Application-Security-Testing-SAST-Tools-for-Smart-Contracts-How-Far-Are-We-)的ACM SIGSOFT Distinguished Paper award通知，感觉很不错，虽然作为二作一直在划水，没有很多的帮忙到位，但正好是与slither相关的，所以这里顺带提一下
## 重入（Re-Entrancy）

重入这个漏洞已经在过去的许多年里被翻来覆去的讨论，被翻来覆去的研究，在学术圈，通常视为一种读写问题，而研究也是这样解决的类似问题，即不论是通过原代码，字节码用来进行静态分析还是动态执行，来找到异常的读写，从而判断重入

这种思路确实是没有问题，但我们要做的并不是单单讨论重入这个漏洞，而是要将其扩展，扩展的方向上有两个：
1. 重入类型的扩展——读写问题是否能够更加细化？更加能够解释更多的重入？
2. 读写问题的扩展——读写问题是否也发生在其它漏洞中？是否有一个通用模型来描述一系列的漏洞？

对于上述两个问题，在过去的几年中，我断断续续的进行了抽象的总结，能够给出一些阶段性结论
1. 重入类型的扩展——读写问题可以更加细化，通过不同的读写冲突问题，能够解释更多的重入
2. 读写问题的扩展——的确，存在一种通用模型，能够将价格操纵，重入，经典的mev抢跑纳入进来，形成一种在智能合约读写问题的理论模型

重入的内容将会分为三篇文章，分别问两个问题的解答，和在slither中的优化方向，本次slither insight 102将着重叙述第一个问题


## 重入类型的扩展——读写问题是否能够更加细化？更加能够解释更多的重入？

感谢我的硕导在我刚接触这个漏洞时提的有先见之明的理论，尝试用数据库的理论来解释重入，也即，脏读，不可重读，虚读

经过很多对于重入时间的分析，发现很有趣的结论：的确，通过对于数据库理论对于读写冲突的推演，我们可以用不同冲突类型来区分不同类型的重入

在这之前，可以复习一下基本的定义：

1. 脏读（Dirty Read）：指一个线程中的事务读取到了另外一个线程中未提交的数据。
2. 不可重读（Non-Repeatable Read）：指一个线程中的事务读取到了另外一个线程中提交的update的数据。
3. 虚读（Phantom Read）：指一个线程中的事务读取到了另外一个线程中提交的insert的数据。

基于这个定义，我们可以发现，实际上，最原始的重入，也就是通过fallback重入来读取了一个尚未被有效更新的balance，可以与脏读相对应：简单的来说，这种重入读取的是首次进入时尚未执行完成的函数逻辑，相当于读了一个旧数据来绕过balance检查；而脏读则是读取到了另外一个线程中未提交的数据，我们可以发现，两种读取的都是一个相对旧的数据。

那么不可重读和虚读有没有对应的，经过其他的分析我们也可以发现，是存在的，以[lendf.me erc777重入攻击](https://blog.csdn.net/BradMoon/article/details/123133041)为例，攻击的本质如下：
1. 项目本身是通过balancebefore和balanceafter计算差值来进行存入金额的统计
2. 攻击者第一次存入的假币，重入过程中充入了真币，这里的两次充入进行了两次差额计算
3. 两次差额计算导致存入1单位的币，计算出了2单位的差额，也即获得了2单位的存储证明
4. 其核心在于外层，或者说第一次存入在计算差额的时候，使用了错误的新数据，本质上第一次存假币时，应该使用旧的数额变化来计算，但是却使用了新的数额变化计算，导致了漏洞

而这个攻击本质，我们可以发现，关键是内层重入有新的数据插入，但是外层错误的读了这个数据，因此我们可以与不可重读或者虚读联系起来，也即，内层重入导致了外层的不可重读或者虚读。当然我们也可以说，外层的不可重读或虚读导致了内层的脏读

总结一下，通过数据库的理论，我们可以发现重入和数据库读写之间的关系，那么实际上，这里面存在很多可以继续扩展的东西，比如说，重入锁可以如何联系？还有哪些可以进行扩展的理论迁移？这都是值得探索的方向。